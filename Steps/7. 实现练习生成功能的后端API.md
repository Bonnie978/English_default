

### 1. æ›´æ–°ç¯å¢ƒé…ç½®ç«¯å£

```typescript
// src/config/env.ts æ›´æ–°ç«¯å£éƒ¨åˆ†
export const config = {
  // æœåŠ¡å™¨é…ç½®
  PORT: process.env.PORT || 3000, // ç«¯å£æ”¹ä¸º3000
  // å…¶ä»–é…ç½®é¡¹ä¿æŒä¸å˜...
};
```

### 2. åˆ›å»ºDeepSeek APIæœåŠ¡

```typescript
// src/services/ai.service.ts
import axios from 'axios';
import { redisClient } from '../config/redis';
import { config } from '../config/env';

// DeepSeek APIæœåŠ¡
class AIService {
  private apiKey: string;
  private baseURL: string;
  private cacheEnabled: boolean;
  private cacheExpiration: number; // ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰

  constructor() {
    this.apiKey = config.DEEPSEEK_API_KEY;
    this.baseURL = config.DEEPSEEK_API_URL;
    this.cacheEnabled = true; // é»˜è®¤å¯ç”¨ç¼“å­˜
    this.cacheExpiration = 24 * 60 * 60; // é»˜è®¤24å°æ—¶
  }

  // ç”Ÿæˆå†…å®¹çš„é€šç”¨æ–¹æ³•
  async generateContent(
    systemPrompt: string,
    userPrompt: string,
    options: any = {}
  ) {
    try {
      // ç”Ÿæˆç¼“å­˜é”®
      const cacheKey = `ai:${this.hashString(systemPrompt + userPrompt)}`;

      // æ£€æŸ¥ç¼“å­˜
      if (this.cacheEnabled) {
        const cachedContent = await redisClient.get(cacheKey);
        if (cachedContent) {
          console.log('ä½¿ç”¨ç¼“å­˜çš„AIå“åº”');
          return JSON.parse(cachedContent);
        }
      }

      // é»˜è®¤å‚æ•°
      const defaultOptions = {
        temperature: 0.7,
        max_tokens: 1000,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0,
      };

      // åˆå¹¶é€‰é¡¹
      const requestOptions = {
        ...defaultOptions,
        ...options,
      };

      // è°ƒç”¨DeepSeek API
      const response = await axios.post(
        `${this.baseURL}/chat/completions`,
        {
          model: 'deepseek-chat',
          messages: [
            {
              role: 'system',
              content: systemPrompt,
            },
            {
              role: 'user',
              content: userPrompt,
            },
          ],
          ...requestOptions,
        },
        {
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${this.apiKey}`,
          },
        }
      );

      const result = {
        content: response.data.choices[0].message.content,
        usage: response.data.usage,
        model: response.data.model,
      };

      // ç¼“å­˜ç»“æœ
      if (this.cacheEnabled) {
        await redisClient.set(
          cacheKey,
          JSON.stringify(result),
          { EX: this.cacheExpiration }
        );
      }

      return result;
    } catch (error) {
      console.error('AIå†…å®¹ç”Ÿæˆé”™è¯¯:', error);
      throw new Error(`AIå†…å®¹ç”Ÿæˆå¤±è´¥: ${error.message}`);
    }
  }

  // ç”Ÿæˆé˜…è¯»ç»ƒä¹ 
  async generateReadingExercise(words: string[], difficulty: string = 'intermediate') {
    const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è‹±è¯­æ•™å¸ˆï¼Œéœ€è¦æ ¹æ®ç»™å®šçš„å•è¯åˆ›å»ºä¸€ç¯‡çŸ­æ–‡å’Œç›¸å…³é—®é¢˜ã€‚éš¾åº¦çº§åˆ«: ${difficulty}`;
    const userPrompt = `è¯·æ ¹æ®ä»¥ä¸‹å•è¯åˆ›å»ºä¸€ç¯‡200å­—å·¦å³çš„çŸ­æ–‡ï¼Œå¹¶æä¾›3-5ä¸ªç›¸å…³é—®é¢˜ï¼Œè¯·ç¡®ä¿é—®é¢˜å¤šæ ·åŒ–ï¼ˆåŒ…å«å•é€‰ã€å¤šé€‰æˆ–å¡«ç©ºé¢˜ï¼‰ã€‚æ¯ä¸ªé—®é¢˜éƒ½å¿…é¡»åŒ…å«æ­£ç¡®ç­”æ¡ˆï¼Œå¦‚æœæ˜¯é€‰æ‹©é¢˜ï¼Œè¯·æ˜ç¡®æ ‡æ³¨æ­£ç¡®é€‰é¡¹: ${words.join(', ')}`;

    const result = await this.generateContent(systemPrompt, userPrompt, {
      temperature: 0.7,
    });

    return this.parseReadingResponse(result.content);
  }

  // ç”Ÿæˆå¬åŠ›ç»ƒä¹ 
  async generateListeningExercise(words: string[], difficulty: string = 'intermediate') {
    const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è‹±è¯­æ•™å¸ˆï¼Œéœ€è¦åˆ›å»ºé€‚åˆå¬åŠ›ç»ƒä¹ çš„å¯¹è¯æˆ–çŸ­æ–‡ã€‚éš¾åº¦çº§åˆ«: ${difficulty}`;
    const userPrompt = `è¯·æ ¹æ®ä»¥ä¸‹å•è¯åˆ›å»ºä¸€æ®µ60-90ç§’çš„å¯¹è¯æˆ–çŸ­æ–‡ï¼Œé€‚åˆä½œä¸ºè‹±è¯­å¬åŠ›ææ–™ï¼Œå¹¶æä¾›3-5ä¸ªç›¸å…³é—®é¢˜ã€‚æ¯ä¸ªé—®é¢˜éƒ½å¿…é¡»åŒ…å«æ­£ç¡®ç­”æ¡ˆï¼Œå¦‚æœæ˜¯é€‰æ‹©é¢˜ï¼Œè¯·æ˜ç¡®æ ‡æ³¨æ­£ç¡®é€‰é¡¹: ${words.join(', ')}`;

    const result = await this.generateContent(systemPrompt, userPrompt, {
      temperature: 0.7,
    });

    return this.parseListeningResponse(result.content);
  }

  // ç”Ÿæˆå†™ä½œç»ƒä¹ 
  async generateWritingExercise(words: string[], difficulty: string = 'intermediate') {
    const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è‹±è¯­å†™ä½œæ•™å¸ˆï¼Œéœ€è¦åˆ›å»ºå†™ä½œæç¤ºã€‚éš¾åº¦çº§åˆ«: ${difficulty}`;
    const userPrompt = `è¯·æ ¹æ®ä»¥ä¸‹å•è¯åˆ›å»ºä¸€ä¸ªå†™ä½œæç¤ºï¼Œè¦æ±‚å­¦ç”Ÿåœ¨å†™ä½œä¸­ä½¿ç”¨è¿™äº›å•è¯ã€‚æä¾›æ˜ç¡®çš„å†™ä½œè¦æ±‚ï¼ŒåŒ…æ‹¬ä¸»é¢˜ã€é•¿åº¦å’Œç»“æ„å»ºè®®: ${words.join(', ')}`;

    const result = await this.generateContent(systemPrompt, userPrompt, {
      temperature: 0.7,
    });

    return this.parseWritingPrompt(result.content);
  }

  // è¯„ä¼°å†™ä½œç»ƒä¹ 
  async evaluateWriting(prompt: string, expectedWords: string[], userAnswer: string) {
    const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è‹±è¯­å†™ä½œè¯„åˆ†ç³»ç»Ÿï¼Œéœ€è¦è¯„ä¼°å­¦ç”Ÿçš„å†™ä½œå¹¶æä¾›è¯¦ç»†åé¦ˆã€‚`;
    const userPrompt = `
      å†™ä½œæç¤º: ${prompt}
      æœŸæœ›ä½¿ç”¨çš„å•è¯: ${expectedWords.join(', ')}
      å­¦ç”Ÿçš„ç­”æ¡ˆ: ${userAnswer}
      
      è¯·è¯„ä¼°å­¦ç”Ÿçš„å†™ä½œå¹¶æä¾›è¯¦ç»†åé¦ˆã€‚è¯„åˆ†ç»´åº¦:
      1. å†…å®¹ç›¸å…³æ€§ (20åˆ†)
      2. å•è¯ä½¿ç”¨æƒ…å†µ (30åˆ†) - ç‰¹åˆ«å…³æ³¨å­¦ç”Ÿæ˜¯å¦æ­£ç¡®ä½¿ç”¨äº†æœŸæœ›çš„å•è¯
      3. è¯­æ³•å’Œæ‹¼å†™ (20åˆ†)
      4. ç»“æ„å’Œè¿è´¯æ€§ (20åˆ†)
      5. è¡¨è¾¾å’Œè¯æ±‡å¤šæ ·æ€§ (10åˆ†)
      
      è¯·ç»™å‡ºæ€»åˆ†(0-100)ï¼Œå¹¶é’ˆå¯¹æ¯ä¸ªç»´åº¦æä¾›å…·ä½“è¯„ä»·å’Œæ”¹è¿›å»ºè®®ã€‚
    `;

    const result = await this.generateContent(systemPrompt, userPrompt, {
      temperature: 0.3,
      max_tokens: 800,
    });

    return this.parseEvaluationResponse(result.content);
  }

  // è§£æé˜…è¯»ææ–™å“åº”
  private parseReadingResponse(content: string) {
    try {
      // åˆ†ç¦»æ–‡ç« å’Œé—®é¢˜
      const articleMatch = content.match(/(.+?)(?=é—®é¢˜|Questions:|Questionsï¼š|Questions)/s);
      const questionsMatch = content.match(/(?:é—®é¢˜|Questions:|Questionsï¼š|Questions)(.+)$/s);
      
      const article = articleMatch ? articleMatch[1].trim() : content;
      let questionsText = questionsMatch ? questionsMatch[1].trim() : '';
      
      // è§£æé—®é¢˜
      const questions = this.extractQuestions(questionsText);
      
      return {
        article,
        questions
      };
    } catch (error) {
      console.error('è§£æé˜…è¯»å“åº”é”™è¯¯:', error);
      return {
        article: content,
        questions: []
      };
    }
  }

  // è§£æå¬åŠ›ææ–™å“åº”ï¼ˆç»“æ„ä¸é˜…è¯»ç±»ä¼¼ï¼‰
  private parseListeningResponse(content: string) {
    return this.parseReadingResponse(content);
  }

  // è§£æå†™ä½œæç¤ºå“åº”
  private parseWritingPrompt(content: string) {
    try {
      // æå–ä¸»é¢˜ã€è¦æ±‚å’Œå»ºè®®
      const topicMatch = content.match(/ä¸»é¢˜[ï¼š:](.*?)(?=è¦æ±‚|è¦ç‚¹|Guidelines|$)/is);
      const requirementsMatch = content.match(/è¦æ±‚[ï¼š:](.*?)(?=å»ºè®®|æç¤º|Tips|$)/is);
      const tipsMatch = content.match(/(?:å»ºè®®|æç¤º)[ï¼š:](.*?)$/is);
      
      return {
        prompt: content,
        topic: topicMatch ? topicMatch[1].trim() : '',
        requirements: requirementsMatch ? requirementsMatch[1].trim() : '',
        tips: tipsMatch ? tipsMatch[1].trim() : ''
      };
    } catch (error) {
      console.error('è§£æå†™ä½œæç¤ºé”™è¯¯:', error);
      return {
        prompt: content,
        topic: '',
        requirements: '',
        tips: ''
      };
    }
  }

  // è§£æè¯„åˆ†å“åº”
  private parseEvaluationResponse(content: string) {
    try {
      // æå–æ€»åˆ†
      const scoreMatch = content.match(/æ€»åˆ†[:ï¼š]?\s*(\d+)/i);
      const score = scoreMatch ? parseInt(scoreMatch[1]) : 0;
      
      // è§£ææ¯ä¸ªç»´åº¦çš„è¯„åˆ†å’Œåé¦ˆ
      const dimensions = [
        { name: 'å†…å®¹ç›¸å…³æ€§', regex: /å†…å®¹ç›¸å…³æ€§[^0-9]*(\d+)[^0-9]*([\s\S]+?)(?=\d+\.|$)/i },
        { name: 'å•è¯ä½¿ç”¨æƒ…å†µ', regex: /å•è¯ä½¿ç”¨æƒ…å†µ[^0-9]*(\d+)[^0-9]*([\s\S]+?)(?=\d+\.|$)/i },
        { name: 'è¯­æ³•å’Œæ‹¼å†™', regex: /è¯­æ³•å’Œæ‹¼å†™[^0-9]*(\d+)[^0-9]*([\s\S]+?)(?=\d+\.|$)/i },
        { name: 'ç»“æ„å’Œè¿è´¯æ€§', regex: /ç»“æ„å’Œè¿è´¯æ€§[^0-9]*(\d+)[^0-9]*([\s\S]+?)(?=\d+\.|$)/i },
        { name: 'è¡¨è¾¾å’Œè¯æ±‡å¤šæ ·æ€§', regex: /è¡¨è¾¾å’Œè¯æ±‡å¤šæ ·æ€§[^0-9]*(\d+)[^0-9]*([\s\S]+?)(?=\d+\.|$)/i }
      ];
      
      const detailedFeedback = dimensions.map(dim => {
        const match = content.match(dim.regex);
        return {
          dimension: dim.name,
          score: match ? parseInt(match[1]) : null,
          feedback: match ? match[2].trim() : null
        };
      }).filter(item => item.score !== null);
      
      // æå–æ€»ä½“æ”¹è¿›å»ºè®®
      const suggestionsMatch = content.match(/æ”¹è¿›å»ºè®®[ï¼š:]([\s\S]+?)(?=\d+\.|$)/i);
      const suggestions = suggestionsMatch ? suggestionsMatch[1].trim() : '';
      
      return {
        score,
        detailedFeedback,
        suggestions,
        rawFeedback: content
      };
    } catch (error) {
      console.error('è§£æè¯„åˆ†å“åº”é”™è¯¯:', error);
      return {
        score: 0,
        detailedFeedback: [],
        suggestions: '',
        rawFeedback: content
      };
    }
  }

  // ä»æ–‡æœ¬ä¸­æå–é—®é¢˜
  private extractQuestions(text: string) {
    if (!text) return [];
    
    // åŒ¹é…é—®é¢˜æ¨¡å¼
    const questionPattern = /(\d+)[\.ã€]\s*([^\n]+)(?:\n((?:[A-D]\.[\s\S]+?(?=\n[A-D]\.|\n\d+\.|\n$|$))+))?/g;
    const questions = [];
    let match;
    
    while ((match = questionPattern.exec(text)) !== null) {
      const questionText = match[2].trim();
      const options = match[3] ? this.extractOptions(match[3]) : [];
      
      // ç¡®å®šé—®é¢˜ç±»å‹
      const questionType = options.length > 0 ? 'multiple-choice' : 'fill-blank';
      
      // æ‰¾å‡ºæ­£ç¡®ç­”æ¡ˆ
      let correctAnswer = '';
      if (questionType === 'multiple-choice') {
        const correctOption = options.find(o => o.isCorrect);
        correctAnswer = correctOption ? correctOption.text : '';
      } else {
        // ä¸ºå¡«ç©ºé¢˜å°è¯•ä»æ–‡æœ¬ä¸­æå–ç­”æ¡ˆ
        const answerMatch = text.match(new RegExp(`${questionText.replace(/\?/, '\\?')}[^]*?ç­”æ¡ˆ[:ï¼š]\\s*(.+?)(?=\\n|$)`, 'i'));
        correctAnswer = answerMatch ? answerMatch[1].trim() : '';
      }
      
      questions.push({
        question: questionText,
        type: questionType,
        options: options.map(o => o.text),
        correctAnswer
      });
    }
    
    return questions;
  }

  // ä»æ–‡æœ¬ä¸­æå–é€‰é¡¹
  private extractOptions(text: string) {
    const optionPattern = /([A-D])\.?\s*([^\n]+)/g;
    const options = [];
    let match;
    
    // æ‰¾å‡ºé€‰é¡¹
    while ((match = optionPattern.exec(text)) !== null) {
      options.push({
        key: match[1],
        text: match[2].trim(),
        isCorrect: false
      });
    }
    
    // æ‰¾å‡ºæ­£ç¡®ç­”æ¡ˆæ ‡è®°
    const correctAnswerMatch = text.match(/æ­£ç¡®ç­”æ¡ˆ[:ï¼š]?\s*([A-D])/i) || 
                              text.match(/ç­”æ¡ˆ[:ï¼š]?\s*([A-D])/i);
    
    if (correctAnswerMatch) {
      const correctKey = correctAnswerMatch[1];
      const correctOption = options.find(o => o.key === correctKey);
      if (correctOption) {
        correctOption.isCorrect = true;
      }
    }
    
    return options;
  }

  // ç®€å•çš„å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°ï¼Œç”¨äºç¼“å­˜é”®
  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return hash.toString(36); // è½¬æ¢ä¸ºåŸºæ•°ä¸º36çš„å­—ç¬¦ä¸²
  }
}

export const aiService = new AIService();
```

### 3. åˆ›å»ºç»ƒä¹ æ§åˆ¶å™¨

```typescript
// src/controllers/exercise.controller.ts
import { Request, Response } from 'express';
import { LearningRecord } from '../models/LearningRecord';
import { Word } from '../models/Word';
import { WrongAnswer } from '../models/WrongAnswer';
import { User } from '../models/User';
import { aiService } from '../services/ai.service';

// ç”Ÿæˆç»ƒä¹ é¢˜
export const generateExercise = async (req: Request, res: Response) => {
  try {
    const { type, wordIds } = req.body;
    
    // éªŒè¯è¾“å…¥
    if (!type || !['read', 'listen', 'write'].includes(type)) {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„ç»ƒä¹ ç±»å‹'
      });
    }
    
    if (!wordIds || !Array.isArray(wordIds) || wordIds.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„å•è¯IDåˆ—è¡¨'
      });
    }
    
    // è·å–å•è¯è¯¦æƒ…
    const words = await Word.find({ _id: { $in: wordIds } });
    
    if (words.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'æœªæ‰¾åˆ°æŒ‡å®šçš„å•è¯'
      });
    }
    
    // æå–å•è¯æ‹¼å†™
    const wordSpellings = words.map(word => word.spelling);
    
    let exercise;
    
    // æ ¹æ®ç±»å‹ç”Ÿæˆä¸åŒç»ƒä¹ 
    switch (type) {
      case 'read':
        exercise = await aiService.generateReadingExercise(wordSpellings);
        break;
      case 'listen':
        exercise = await aiService.generateListeningExercise(wordSpellings);
        break;
      case 'write':
        exercise = await aiService.generateWritingExercise(wordSpellings);
        break;
      default:
        return res.status(400).json({
          success: false,
          message: 'ä¸æ”¯æŒçš„ç»ƒä¹ ç±»å‹'
        });
    }
    
    // è·å–ä»Šå¤©çš„å­¦ä¹ è®°å½•
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    let learningRecord = await LearningRecord.findOne({
      userId: req.user._id,
      date: {
        $gte: today,
        $lt: tomorrow
      }
    });
    
    if (!learningRecord) {
      return res.status(404).json({
        success: false,
        message: 'æœªæ‰¾åˆ°ä»Šæ—¥å­¦ä¹ è®°å½•'
      });
    }
    
    // å°†ç»ƒä¹ æ·»åŠ åˆ°å­¦ä¹ è®°å½•ä¸­
    if (type === 'read' || type === 'listen') {
      learningRecord.exercises.push({
        type,
        content: exercise.article,
        questions: exercise.questions.map(q => ({
          question: q.question,
          options: q.options,
          type: q.type,
          correctAnswer: q.correctAnswer
        }))
      });
    } else if (type === 'write') {
      learningRecord.exercises.push({
        type,
        content: exercise.prompt,
        questions: [{
          question: exercise.topic,
          type: 'writing',
          correctAnswer: wordSpellings.join(',') // ä»¥é€—å·åˆ†éš”çš„ç›®æ ‡å•è¯ä½œä¸º"æ­£ç¡®ç­”æ¡ˆ"
        }]
      });
    }
    
    await learningRecord.save();
    
    // è·å–åˆšæ·»åŠ çš„ç»ƒä¹ ID
    const exerciseId = learningRecord.exercises[learningRecord.exercises.length - 1]._id;
    
    // æ ¹æ®ç»ƒä¹ ç±»å‹æ„å»ºå“åº”
    let response;
    
    if (type === 'read') {
      response = {
        id: exerciseId,
        type: 'read',
        content: exercise.article,
        questions: exercise.questions.map(q => ({
          id: q._id || Math.random().toString(36).substring(2, 15),
          question: q.question,
          options: q.options,
          type: q.type
        }))
      };
    } else if (type === 'listen') {
      response = {
        id: exerciseId,
        type: 'listen',
        content: exercise.article,
        questions: exercise.questions.map(q => ({
          id: q._id || Math.random().toString(36).substring(2, 15),
          question: q.question,
          options: q.options,
          type: q.type
        }))
      };
      
      // æ³¨æ„ï¼šè¿™é‡Œåº”è¯¥ç”ŸæˆéŸ³é¢‘URLï¼Œä½†åœ¨æ­¤ç¤ºä¾‹ä¸­çœç•¥
      // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥é›†æˆå¦‚AWS Pollyç­‰æœåŠ¡ç”ŸæˆéŸ³é¢‘
      response.audioUrl = '/api/exercises/audio/' + exerciseId;
    } else {
      response = {
        id: exerciseId,
        type: 'write',
        content: exercise.prompt,
        topic: exercise.topic,
        requirements: exercise.requirements,
        tips: exercise.tips,
        targetWords: wordSpellings
      };
    }
    
    res.status(201).json({
      success: true,
      exercise: response
    });
  } catch (error) {
    console.error('ç”Ÿæˆç»ƒä¹ é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åå†è¯•'
    });
  }
};

// æäº¤ç»ƒä¹ ç­”æ¡ˆ
export const submitExerciseAnswer = async (req: Request, res: Response) => {
  try {
    const { exerciseId } = req.params;
    const { answers } = req.body;
    
    if (!exerciseId || !answers || !Array.isArray(answers)) {
      return res.status(400).json({
        success: false,
        message: 'æ— æ•ˆçš„è¯·æ±‚æ•°æ®'
      });
    }
    
    // è·å–å­¦ä¹ è®°å½•
    const learningRecord = await LearningRecord.findOne({
      userId: req.user._id,
      'exercises._id': exerciseId
    });
    
    if (!learningRecord) {
      return res.status(404).json({
        success: false,
        message: 'æœªæ‰¾åˆ°æŒ‡å®šçš„ç»ƒä¹ '
      });
    }
    
    // æ‰¾åˆ°æŒ‡å®šçš„ç»ƒä¹ 
    const exercise = learningRecord.exercises.find(
      ex => ex._id.toString() === exerciseId
    );
    
    if (!exercise) {
      return res.status(404).json({
        success: false,
        message: 'æœªæ‰¾åˆ°æŒ‡å®šçš„ç»ƒä¹ '
      });
    }
    
    // åˆ¤æ–­ç­”æ¡ˆæ˜¯å¦æ­£ç¡®å¹¶è®¡ç®—å¾—åˆ†
    let score = 0;
    let totalQuestions = exercise.questions.length;
    let wrongAnswersAdded = 0;
    
    // æ ¹æ®ä¸åŒç±»å‹çš„ç»ƒä¹ å¤„ç†ç­”æ¡ˆ
    if (exercise.type === 'read' || exercise.type === 'listen') {
      // å¤„ç†é€‰æ‹©é¢˜å’Œå¡«ç©ºé¢˜
      const detailedResults = [];
      
      for (let i = 0; i < exercise.questions.length; i++) {
        const question = exercise.questions[i];
        const answer = answers.find(a => a.questionId === question._id.toString());
        
        if (!answer) continue;
        
        // æ›´æ–°ç”¨æˆ·ç­”æ¡ˆ
        question.userAnswer = answer.answer;
        
        // åˆ¤æ–­æ˜¯å¦æ­£ç¡®
        const isCorrect = question.correctAnswer.trim().toLowerCase() === 
                         answer.answer.trim().toLowerCase();
        
        question.isCorrect = isCorrect;
        
        if (isCorrect) {
          score++;
        } else {
          // æ·»åŠ åˆ°é”™é¢˜é›†
          try {
            // è·å–ä¸ç»ƒä¹ ç›¸å…³çš„å•è¯ID
            const wordNames = question.question.split(' ').filter(w => w.length > 4);
            const relatedWords = await Word.find({
              spelling: { $in: wordNames }
            });
            
            await WrongAnswer.create({
              userId: req.user._id,
              exerciseId,
              wordIds: relatedWords.map(w => w._id),
              type: exercise.type,
              question: question.question,
              correctAnswer: question.correctAnswer,
              userAnswer: answer.answer,
              date: new Date(),
              reviewed: false
            });
            
            wrongAnswersAdded++;
          } catch (error) {
            console.error('æ·»åŠ é”™é¢˜é”™è¯¯:', error);
          }
        }
        
        detailedResults.push({
          questionId: question._id,
          isCorrect,
          correctAnswer: question.correctAnswer,
          explanation: isCorrect ? 'å›ç­”æ­£ç¡®ï¼' : `æ­£ç¡®ç­”æ¡ˆæ˜¯: ${question.correctAnswer}`
        });
      }
      
      // è®¡ç®—ç™¾åˆ†æ¯”å¾—åˆ†
      const percentageScore = Math.round((score / totalQuestions) * 100);
      exercise.score = percentageScore;
      exercise.completedAt = new Date();
      
      // ç”Ÿæˆåé¦ˆ
      const feedback = this.generateFeedback(percentageScore);
      exercise.feedback = feedback;
      
      await learningRecord.save();
      
      // æ›´æ–°ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
      const user = await User.findById(req.user._id);
      user.learningStats.totalExercises += 1;
      await user.save();
      
      return res.status(200).json({
        success: true,
        score: percentageScore,
        feedback,
        detailedResults,
        wrongAnswersAdded
      });
    } else if (exercise.type === 'write') {
      // å¤„ç†å†™ä½œé¢˜
      const { answer } = answers[0];
      const targetWords = exercise.questions[0].correctAnswer.split(',');
      
      // æ›´æ–°ç”¨æˆ·ç­”æ¡ˆ
      exercise.questions[0].userAnswer = answer;
      
      // è¯„ä¼°å†™ä½œ
      const evaluation = await aiService.evaluateWriting(
        exercise.content,
        targetWords,
        answer
      );
      
      exercise.score = evaluation.score;
      exercise.feedback = evaluation.rawFeedback;
      exercise.completedAt = new Date();
      
      await learningRecord.save();
      
      // æ›´æ–°ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
      const user = await User.findById(req.user._id);
      user.learningStats.totalExercises += 1;
      await user.save();
      
      return res.status(200).json({
        success: true,
        score: evaluation.score,
        feedback: evaluation.rawFeedback,
        detailedFeedback: evaluation.detailedFeedback,
        suggestions: evaluation.suggestions
      });
    }
    
    res.status(400).json({
      success: false,
      message: 'ä¸æ”¯æŒçš„ç»ƒä¹ ç±»å‹'
    });
  } catch (error) {
    console.error('æäº¤ç­”æ¡ˆé”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åå†è¯•'
    });
  }
};

// ç”Ÿæˆåé¦ˆçš„è¾…åŠ©æ–¹æ³•
private generateFeedback(score: number): string {
  if (score >= 90) {
    return 'å¤ªæ£’äº†ï¼ä½ çš„è¡¨ç°éå¸¸å‡ºè‰²ï¼Œå‡ ä¹æ‰€æœ‰é—®é¢˜éƒ½ç­”å¯¹äº†ã€‚ç»§ç»­ä¿æŒï¼';
  } else if (score >= 80) {
    return 'åšå¾—å¾ˆå¥½ï¼ä½ å¯¹è¿™äº›å•è¯çš„æŒæ¡å·²ç»ç›¸å½“ä¸é”™äº†ã€‚';
  } else if (score >= 70) {
    return 'è¡¨ç°è‰¯å¥½ï¼è™½ç„¶æœ‰ä¸€äº›é”™è¯¯ï¼Œä½†ä½ å·²ç»åœ¨æ­£ç¡®çš„é“è·¯ä¸Šäº†ã€‚';
  } else if (score >= 60) {
    return 'åˆæ ¼çš„è¡¨ç°ã€‚å»ºè®®ä½ é‡æ–°å¤ä¹ ä¸€ä¸‹è¿™äº›å•è¯ï¼Œç‰¹åˆ«æ˜¯é”™è¯¯çš„éƒ¨åˆ†ã€‚';
  } else {
    return 'çœ‹èµ·æ¥è¿™äº›å•è¯è¿˜éœ€è¦æ›´å¤šçš„ç»ƒä¹ ã€‚å»ºè®®ä½ å›å»å¤ä¹ ï¼Œç„¶åå†å°è¯•ä¸€æ¬¡ã€‚';
  }
}

// è·å–é”™é¢˜åˆ—è¡¨
export const getWrongAnswers = async (req: Request, res: Response) => {
  try {
    const { page = 1, limit = 20, type } = req.query;
    
    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const query: any = { userId: req.user._id };
    
    if (type && ['read', 'listen', 'write'].includes(type as string)) {
      query.type = type;
    }
    
    // è®¡ç®—åˆ†é¡µ
    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const skip = (pageNum - 1) * limitNum;
    
    // è·å–é”™é¢˜æ€»æ•°
    const total = await WrongAnswer.countDocuments(query);
    
    // è·å–é”™é¢˜åˆ—è¡¨
    const wrongAnswers = await WrongAnswer.find(query)
      .sort({ date: -1 })
      .skip(skip)
      .limit(limitNum)
      .populate('wordIds', 'spelling definitions');
    
    // æ ¼å¼åŒ–å“åº”æ•°æ®
    const formattedWrongAnswers = wrongAnswers.map(wrong => {
      return {
        id: wrong._id,
        type: wrong.type,
        typeName: this.getTypeName(wrong.type),
        question: wrong.question,
        correctAnswer: wrong.correctAnswer,
        userAnswer: wrong.userAnswer,
        date: wrong.date,
        formattedDate: this.formatDate(wrong.date),
        reviewed: wrong.reviewed,
        relatedWords: wrong.wordIds.map((word: any) => ({
          id: word._id,
          spelling: word.spelling,
          definition: word.definitions[0]
        }))
      };
    });
    
    res.status(200).json({
      success: true,
      total,
      page: pageNum,
      limit: limitNum,
      wrongAnswers: formattedWrongAnswers
    });
  } catch (error) {
    console.error('è·å–é”™é¢˜åˆ—è¡¨é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åå†è¯•'
    });
  }
};

// æ ‡è®°é”™é¢˜ä¸ºå·²å¤ä¹ 
export const markWrongAsReviewed = async (req: Request, res: Response) => {
  try {
    const { wrongAnswerId } = req.params;
    
    const wrongAnswer = await WrongAnswer.findOne({
      _id: wrongAnswerId,
      userId: req.user._id
    });
    
    if (!wrongAnswer) {
      return res.status(404).json({
        success: false,
        message: 'æœªæ‰¾åˆ°æŒ‡å®šçš„é”™é¢˜'
      });
    }
    
    wrongAnswer.reviewed = true;
    wrongAnswer.reviewedAt = new Date();
    
    await wrongAnswer.save();
    
    res.status(200).json({
      success: true,
      message: 'å·²æ ‡è®°ä¸ºå·²å¤ä¹ ',
      reviewed: true,
      reviewedAt: wrongAnswer.reviewedAt
    });
  } catch (error) {
    console.error('æ ‡è®°é”™é¢˜é”™è¯¯:', error);
    res.status(500).json({
      success: false,
      message: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åå†è¯•'
    });
  }
};

// è·å–ç»ƒä¹ ç±»å‹åç§°
private getTypeName(type: string): string {
  switch (type) {
    case 'read': return 'é˜…è¯»ç†è§£';
    case 'listen': return 'å¬åŠ›ç†è§£';
    case 'write': return 'å†™ä½œç»ƒä¹ ';
    default: return 'æœªçŸ¥ç±»å‹';
  }
}

// æ ¼å¼åŒ–æ—¥æœŸ
private formatDate(date: Date): string {
  return date.toISOString().split('T')[0].replace(/-/g, 'å¹´') + 'æ—¥';
}
```



### 4. åˆ›å»ºç»ƒä¹ è·¯ç”±

```typescript
// src/routes/exercise.routes.ts
import { Router } from 'express';
import { 
  generateExercise, 
  submitExerciseAnswer, 
  getWrongAnswers,
  markWrongAsReviewed
} from '../controllers/exercise.controller';
import { authenticate } from '../middleware/auth.middleware';

const router = Router();

// æ‰€æœ‰è·¯ç”±éƒ½éœ€è¦èº«ä»½éªŒè¯
router.use(authenticate);

// ç”Ÿæˆç»ƒä¹ é¢˜
router.post('/generate', generateExercise);

// æäº¤ç­”æ¡ˆ
router.post('/:exerciseId/submit', submitExerciseAnswer);

// è·å–é”™é¢˜åˆ—è¡¨
router.get('/wrong-answers', getWrongAnswers);

// æ ‡è®°é”™é¢˜ä¸ºå·²å¤ä¹ 
router.post('/wrong-answers/:wrongAnswerId/review', markWrongAsReviewed);

export default router;
```

### 5. æ›´æ–°åº”ç”¨å…¥å£æ–‡ä»¶ï¼Œæ·»åŠ ç»ƒä¹ è·¯ç”±

```typescript
// src/index.ts æ›´æ–°
import express from 'express';
import cors from 'cors';
import { config } from './config/env';
import { connectMongoDB } from './config/database';
import { connectRedis } from './config/redis';
import authRoutes from './routes/auth.routes';
import wordRoutes from './routes/word.routes';
import exerciseRoutes from './routes/exercise.routes'; // æ·»åŠ ç»ƒä¹ è·¯ç”±

// åˆå§‹åŒ–Expressåº”ç”¨
const app = express();

// ä¸­é—´ä»¶
app.use(express.json({ limit: '10mb' })); // å¢åŠ é™åˆ¶ä»¥å¤„ç†å¯èƒ½çš„è¾ƒå¤§è¯·æ±‚ä½“
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cors({
  origin: config.CORS_ORIGIN,
  credentials: true
}));

// è¿æ¥æ•°æ®åº“
(async () => {
  await connectMongoDB();
  await connectRedis();
})();

// è·¯ç”±
app.get('/', (req, res) => {
  res.json({ message: 'Welcome to Vocabulary App API' });
});

// æ·»åŠ APIè·¯ç”±
app.use('/api/auth', authRoutes);
app.use('/api/words', wordRoutes);
app.use('/api/exercises', exerciseRoutes); // æ·»åŠ ç»ƒä¹ è·¯ç”±

// å¯åŠ¨æœåŠ¡å™¨
app.listen(config.PORT, () => {
  console.log(`ğŸš€ Server running on port ${config.PORT} in ${config.NODE_ENV} mode`);
});
```

### éªŒè¯æ­¥éª¤

è¦éªŒè¯ç»ƒä¹ åŠŸèƒ½çš„å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤è¿›è¡Œæµ‹è¯•ï¼š

1. **å¯åŠ¨æœåŠ¡å™¨**:
```bash
npm run dev  # ç°åœ¨æœåŠ¡å™¨åº”è¯¥è¿è¡Œåœ¨ç«¯å£3000ä¸Š
```

2. **å…ˆæ³¨å†Œæˆ–ç™»å½•è·å–token**:
```bash
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}'
```
ä¿å­˜è¿”å›çš„tokenç”¨äºåç»­è¯·æ±‚ã€‚

3. **è·å–ä»Šæ—¥å•è¯ID**:
```bash
curl -X GET http://localhost:3000/api/words/daily \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```
ä»å“åº”ä¸­è®°å½•ä¸‹å‡ ä¸ªå•è¯çš„IDä»¥ç”¨äºç”Ÿæˆç»ƒä¹ é¢˜ã€‚

4. **ç”Ÿæˆé˜…è¯»ç»ƒä¹ **:
```bash
curl -X POST http://localhost:3000/api/exercises/generate \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "type": "read",
    "wordIds": ["WORD_ID_1", "WORD_ID_2", "WORD_ID_3", "WORD_ID_4", "WORD_ID_5"]
  }'
```
é¢„æœŸç»“æœï¼šè¿”å›ä¸€ä¸ªåŒ…å«é˜…è¯»æ–‡ç« å’Œé—®é¢˜çš„ç»ƒä¹ ã€‚ä¿å­˜è¿”å›çš„exerciseIdã€‚

5. **æäº¤é˜…è¯»ç»ƒä¹ ç­”æ¡ˆ**:
```bash
curl -X POST http://localhost:3000/api/exercises/EXERCISE_ID/submit \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{
    "answers": [
      {
        "questionId": "QUESTION_ID_1",
        "answer": "YOUR_ANSWER_1"
      },
      {
        "questionId": "QUESTION_ID_2",
        "answer": "YOUR_ANSWER_2"
      }
    ]
  }'
```
é¢„æœŸç»“æœï¼šè¿”å›å¾—åˆ†ã€åé¦ˆå’Œè¯¦ç»†ç»“æœã€‚

6. **è·å–é”™é¢˜åˆ—è¡¨**:
```bash
curl -X GET "http://localhost:3000/api/exercises/wrong-answers?page=1&limit=10" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```
é¢„æœŸç»“æœï¼šè¿”å›ç”¨æˆ·é”™é¢˜åˆ—è¡¨ï¼ŒåŒ…æ‹¬é—®é¢˜ã€ç­”æ¡ˆå’Œç›¸å…³å•è¯ã€‚

7. **æ ‡è®°é”™é¢˜ä¸ºå·²å¤ä¹ **:
```bash
curl -X POST http://localhost:3000/api/exercises/wrong-answers/WRONG_ANSWER_ID/review \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```
é¢„æœŸç»“æœï¼šè¿”å›æˆåŠŸæ¶ˆæ¯ï¼Œé”™é¢˜çŠ¶æ€æ›´æ–°ä¸ºå·²å¤ä¹ ã€‚

